<!DOCTYPE html>
<html>
<head>
	<title>Relative Studios</title>
	<style>
		html, body { margin: 0; padding:0; overflow: hidden; }
        h1 { color:white; position:absolute; top:75%;
        z-index:100; width:100%; text-align: center; 
        transform: translate(0,-100%); font-family: 
        ‘Raleway’, sans-serif; font-weight: 100; 
        letter-spacing: 40px; text-transform: 
        uppercase; font-size: 30px; }        
	</style>
</head>
<body>
	<script type="module">
        import * as THREE from './loaders/three.module.js';
        import { OBJLoader } from './loaders/OBJLoader.js';
        import { GLTFLoader } from './loaders/GLTFLoader.js';
        import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

        const clock = new THREE.Clock();

		var num=50;
        var objects=[];
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        var light,t;
        var littleM;
        var bigM;
        var light1, light2, light3, light4;

        // create camera
        var camera = new THREE.PerspectiveCamera
        ( 65, window.innerWidth/window.innerHeight, 
        0.1, 1000 );
        // X, Y, Z, zoom?
        camera.position.set(5.5,8,2);
        // create a scene
        var scene = new THREE.Scene();

        // create renderer
        var renderer = new THREE.WebGLRenderer(
        {antialias:true});
        renderer.setSize( window.innerWidth, window.
        innerHeight );
        document.body.appendChild( renderer.domElement 
        );

        //Create a Spot light
        light = new THREE.SpotLight( 0xccddff,.8 );
        light.position.set(0,0,5);
        scene.add( light );

         // Load Light
        var ambientLight = new THREE.AmbientLight( 0xcccccc );
        scene.add( ambientLight );

        // DIRECTIONAL LIGHT
        var directionalLight = new THREE.DirectionalLight( 0xffffff );
        directionalLight.position.set( 0, 1, 1 ).normalize();
        scene.add( directionalLight );		








        const sphere = new THREE.SphereGeometry( 0.5, 16, 8 );

        //lights

        light1 = new THREE.PointLight( 0xffffff, 0.5, 50 );
        // light1.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xff0040 } ) ) );
        scene.add( light1 );

        light2 = new THREE.PointLight( 0xffffff, 0.5, 50 );
        // light2.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x0040ff } ) ) );
        scene.add( light2 );

        light3 = new THREE.PointLight( 0xffffff, 0.5, 50 );
        // light3.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x80ff80 } ) ) );
        scene.add( light3 );

        light4 = new THREE.PointLight( 0xffffff, 0.5, 50 );
        // light4.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffaa00 } ) ) );
        scene.add( light4 );













        var animate = function () {
            for (let i=0;i<=num;i++){
                var o = objects[i];
                o.rotation.y+=.01;
                if( i % 2 == 0) { 
                    o.radians+=.005; o.radians2+=.005;
                } else {
                    o.radians-=.005; o.radians2-=.005;
                }
                o.position.x = (Math.cos(o.radians) * o.distance);
                o.position.z = (Math.sin(o.radians) * o.distance);
                o.position.y = (Math.sin(o.radians2) * o.distance*.5);
            }



            const time = Date.now() * 0.0005;
				const delta = clock.getDelta();
				light1.position.x = Math.sin( time * 2.7 ) * 3;
				light1.position.y = Math.cos( time * 2.5 ) * 4;
				light1.position.z = Math.cos( time * 2.3 ) * 3;
				light2.position.x = Math.cos( time * 2.3 ) * 3;
				light2.position.y = Math.sin( time * 2.5 ) * 4;
				light2.position.z = Math.sin( time * 2.7 ) * 3;
				light3.position.x = Math.sin( time * 2.7 ) * 3;
				light3.position.y = Math.cos( time * 2.3 ) * 4;
				light3.position.z = Math.sin( time * 2.5 ) * 3;
				light4.position.x = Math.sin( time * 2.3 ) * 3;
				light4.position.y = Math.cos( time * 2.7 ) * 4;
				light4.position.z = Math.sin( time * 2.5 ) * 3;


            requestAnimationFrame( animate );
            // littleM.rotation.y -= 0.005;
            // bigM.rotation.y -= -0.005;
            // camera.lookAt(t.position);
            // console.log('littleM.position: ', littleM.position);
            // camera.lookAt(littleM.position);
            renderer.render(scene, camera);
        };

        // load a ground texture
        var texture = new THREE.TextureLoader().load('./lava.jpeg');
        texture.wrapS = texture.wrapT = THREE.
        RepeatWrapping;
        texture.repeat.set (12,12);


        // create ground material
        let lavaMaterial = new THREE.MeshPhysicalMaterial({map:texture,bumpMap:texture});

        // load object texture
        var metalTexture = new THREE.TextureLoader().load('./metal.jpg');


        // create ground mesh
        var geometry = new THREE.PlaneBufferGeometry
        ( 100,100 );
        var ground = new THREE.Mesh( geometry, 
        lavaMaterial );
        ground.rotation.z = Math.PI/180 * -45;
        ground.rotation.x = Math.PI/180 * -90;
        ground.position.y=-2.0;
        // scene.add(ground);


        var envMap = new THREE.CubeTextureLoader()
        .setPath( 'skybox/')
        .load( [ 'right.jpg', 'left.jpg', 'top.jpg', 'bottom.jpg', 'front.jpg', 'back.jpg' ] );


        // create Tetrahedron
        // var geometry = new THREE.TetrahedronBufferGeometry(2,0);
        var metalMaterial = new THREE.MeshPhysicalMaterial( { map:metalTexture,   envMap:envMap, metalness:0.9,roughness:1.4 });
        // t = new THREE.Mesh( geometry, metalMaterial );
        // t.rotation.x=Math.PI/180*-10;
        // scene.add( t );

        for (let i=0;i<=num;i++){
            // create new mesh
            var geometry = new THREE.SphereBufferGeometry( .1,6,6  );
            var material = new THREE.MeshPhysicalMaterial( { envMap:envMap, metalness:1.0 } ) ;
            var particle = new THREE.Mesh( geometry, material );

            // set random position
            particle.position.set(Math.random()*100.0 - 
            50.0,0.0 ,Math.random()* - 10.0 );
            // calc distnace as constant and assign 
            // to object
            var a = new THREE.Vector3( 0, 0, 0 );
            var b = particle.position;
            var d = a.distanceTo( b );
            particle.distance = d;    


            // define 2 random but constant angles 
            // in radians
            particle.radians = Math.random()*360 * Math.
            PI/180; // initial angle
            particle.radians2 = Math.random()*360 * Math.
            PI/180; // initial angle    

            // add object to scene
            scene.add( particle );	
            // add to collection
            objects.push( particle );     
        }


















        // const loader = new GLTFLoader();
        // loader.load( './gltf/big.glb', function (gltf) {
        //     littleM = gltf.scene
        //     gltf.scene.scale.set( 2, 2, 2 );
        //     gltf.scene.position.x = .1;				    //Position (x = right+ left-) 
        //     gltf.scene.position.y = .1;				    //Position (y = up+, down-)
	    //     gltf.scene.position.z = .1;				    //Position (z = front +, back-)
	    //     scene.add( gltf.scene );            
        // },
        // // called while loading is progressing
        // function ( xhr ) {
        //     console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
        // },
        // // called when loading has errors
        // function ( error ) {
        //     console.log( 'An error happened' );
        // })


        // OBJ
        // instantiate a loader
        const loader = new OBJLoader();

        // load a resource
        loader.load(
            // resource URL
            'models/little.obj',
            // called when resource is loaded
            function ( object ) {


                object.traverse( function( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        child.material = metalMaterial;
                    }
                } );


                littleM = object
                object.scale.set( .002, .002, .002 );
                object.position.x = 0;
                object.position.y = -0.35;
                object.position.z = 0.15;
                scene.add( littleM );
            },
            // called when loading is in progresses
            function ( xhr ) {
                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // called when loading has errors
            function ( error ) {
                console.log( 'An error happened' );
            }
        );

        // load a resource
        loader.load(
            // resource URL
            'models/big.obj',
            // called when resource is loaded
            function ( object ) {

                object.traverse( function( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        child.material = metalMaterial;
                    }
                } );

                bigM = object
                object.scale.set( .002, .002, .002 );
                object.position.x = 0;
                object.position.y = 0;
                object.position.z = 0;
                scene.add( bigM );
            },
            // called when loading is in progresses
            function ( xhr ) {
                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // called when loading has errors
            function ( error ) {
                console.log( 'An error happened' );
            }
        );


            let controls = new OrbitControls( camera, renderer.domElement );
            controls.enableZoom = true;



        // start animation loop
        animate();

</script>
<h1>Miles Morgan Photography</h1>
</body>
</html>
