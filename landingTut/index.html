<!DOCTYPE html>
<html>
<head>
	<title>Relative Studios</title>
	<style>
		html, body { margin: 0; padding:0; overflow: hidden; }
        body { background-color: #000000;}
        h1 { color:white; position:absolute; top:75%;
        z-index:100; width:100%; text-align: center; 
        transform: translate(0,-100%); font-family: 
        ‘Raleway’, sans-serif; font-weight: 100; 
        letter-spacing: 40px; text-transform: 
        uppercase; font-size: 30px; }        
	</style>
</head>
<body>
	<script type="module">
        import * as THREE from './loaders/three.module.js';
        import { OBJLoader } from './loaders/OBJLoader.js';
        import { GLTFLoader } from './loaders/GLTFLoader.js';
        import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

        const clock = new THREE.Clock();

		var num=50;
        var objects=[];
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        var light,t;
        var littleM;
        var bigM;
        var light1, light2, light3, light4;
        var spotLight;
        const smokeParticles = [];





        










            const meshGeometry = new THREE.BoxGeometry(200, 200, 200);
            const meshMaterial = new THREE.MeshLambertMaterial({
                color: 0xaa6666,
                wireframe: false
            });
            let smokeMesh = new THREE.Mesh(meshGeometry, meshMaterial);
            let cubeSineDriver = 0;

            let evolveSmoke = (delta) => {
                let smokeParticlesLength = smokeParticles.length;

                while(smokeParticlesLength--) {
                    // console.log('update')
                    // console.log('smokeParticles[smokeParticlesLength]: ', smokeParticles[smokeParticlesLength])
                    smokeParticles[smokeParticlesLength].rotation.z += delta * 0.2;
                }
            }


            let addParticles = () => {
                const textureLoader = new THREE.TextureLoader();

                textureLoader.load('https://rawgit.com/marcobiedermann/playground/master/three.js/smoke-particles/dist/assets/images/clouds.png', texture => {
                    const smokeMaterial = new THREE.MeshLambertMaterial({
                        color: 0xffffff,
                        map: texture,
                        transparent: true
                    });
                    smokeMaterial.map.minFilter = THREE.LinearFilter;
                    const smokeGeometry = new THREE.PlaneBufferGeometry(100, 100);

                    const smokeMeshes = [];
                    let limit = 2;

                    while(limit--) {
                        smokeMeshes[limit] = new THREE.Mesh(smokeGeometry, smokeMaterial);
                        smokeMeshes[limit].position.set(Math.random() * 50, Math.random() * 50, Math.random() * 10 - 100);
                        smokeMeshes[limit].rotation.z = Math.random() * 360;
                        smokeParticles.push(smokeMeshes[limit]);
                        scene.add(smokeMeshes[limit]);
                    }
                });
            }


            addParticles()






            






























        // create camera
        var camera = new THREE.PerspectiveCamera
            ( 65, window.innerWidth/window.innerHeight, 
            0.1, 1000 );
        // X, Y, Z, zoom?
        camera.position.set(5,10,45);

        // create a scene
        var scene = new THREE.Scene();

        // create renderer
        var renderer = new THREE.WebGLRenderer(
            // {antialias:true});
            {antialias:true, alpha: true});
            renderer.setSize( window.innerWidth, window.
            innerHeight );
            document.body.appendChild( renderer.domElement 
        );
        renderer.shadowMap.enabled = true;



        
        //Create a Spot light
        // light = new THREE.SpotLight( 0xccddff,.8 );
        // light.position.set(0,0,5);
        // scene.add( light );

         // Load Light
        // var ambientLight = new THREE.AmbientLight( 0xcccccc );
        // scene.add( ambientLight );

        // DIRECTIONAL LIGHT
        // var directionalLight = new THREE.DirectionalLight( 0xffffff );
        // directionalLight.position.set( 0, 1, 1 ).normalize();
        // scene.add( directionalLight );		





        // SPOTLIGHT FAIL
        // const spotlightDistance = 50.0;
        // const spotlightAngle = Math.PI / 10;
        // const spotlightPenumbra = 1;
        // const spotlightDecay = 0.55;

        // spotLight = new THREE.SpotLight(
        //     0xFFFFFF, 2.0, spotlightDistance, spotlightAngle, spotlightPenumbra, spotlightDecay);


        // spotLight.position.set(10, 10, 10)

        // console.log(spotLight.target)

        // scene.add(spotLight)
        // scene.add(spotLight.target)

        // const spotLightHelper = new THREE.SpotLightHelper( spotLight );
        // scene.add( spotLightHelper );




        spotLight = new THREE.SpotLight(0xccddff,2);

        spotLight.castShadow = true;
        spotLight.shadow.bias = 0.0001;
        spotLight.shadow.mapSize.width = 1024*4;
        spotLight.shadow.mapSize.height = 1024*4;

        scene.add(spotLight)

        // const spotLightHelper = new THREE.SpotLightHelper( spotLight );
        // scene.add( spotLightHelper );















        const sphere = new THREE.SphereGeometry( 0.05, 16, 8 );

        //lights 
        // orb lights orblights
        // PointLight( color : Integer, intensity : Float, distance : Number, decay : Float )
        // light1 = new THREE.PointLight( 0xffffff, 3.5, 50, 0.5 );
        // light1.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffffff } ) ) );
        // scene.add( light1 );

        // light2 = new THREE.PointLight( 0xffffff, 1.5, 50 );
        // light2.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffffff } ) ) );
        // scene.add( light2 );

        // light3 = new THREE.PointLight( 0xffffff, 3.5, 50 );
        // light3.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffffff } ) ) );
        // scene.add( light3 );

        // light4 = new THREE.PointLight( 0xffffff, 1.5, 50 );
        // light4.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffffff } ) ) );
        // scene.add( light4 );









        





        var animate = function () {



            // spotLight.position.set(
            //     camera.position.x + 10,
            //     camera.position.y + 10,
            //     camera.position.z + 10,
            // )


            // ORBITALS
            // for (let i=0;i<=num;i++){
            //     var o = objects[i];
            //     o.rotation.y+=.01;
            //     if( i % 2 == 0) { 
            //         o.radians+=.005; o.radians2+=.005;
            //     } else {
            //         o.radians-=.005; o.radians2-=.005;
            //     }
            //     o.position.x = (Math.cos(o.radians) * o.distance);
            //     o.position.z = (Math.sin(o.radians) * o.distance);
            //     o.position.y = (Math.sin(o.radians2) * o.distance*.5);
            // }
            


            // LIGHT ORBS
            const time = Date.now() * 0.0005;

            const delta = clock.getDelta();
				// light1.position.x = (Math.sin( time * 2.7 ) * 30) + 20;
				// light1.position.y = (Math.cos( time * 2.5 ) * 40) + 20;
				// light1.position.z = (Math.cos( time * 2.3 ) * 30) + 20;
				// light2.position.x = (Math.sin( time * 2.7 ) * 30) - 20;
                // light2.position.y = (Math.cos( time * 2.5 ) * 40) + 20;
                // light2.position.z = (Math.cos( time * 2.3 ) * 30) + 20;
                // light2.position.x = Math.cos( time * 2.3 ) * 3;
				// light2.position.y = Math.sin( time * 2.5 ) * 4;
				// light2.position.z = Math.sin( time * 2.7 ) * 3;
				// light3.position.x = Math.sin( time * 2.7 ) * 3;
				// light3.position.y = Math.cos( time * 2.3 ) * 4;
				// light3.position.z = Math.sin( time * 2.5 ) * 3;
				// light4.position.x = Math.sin( time * 2.3 ) * 3;
				// light4.position.y = Math.cos( time * 2.7 ) * 4;
				// light4.position.z = Math.sin( time * 2.5 ) * 3;



            // SMOKE
            evolveSmoke(delta);



            cubeSineDriver += 0.01;
            smokeMesh.rotation.x += 0.005;
            smokeMesh.rotation.y += 0.01;
            smokeMesh.position.z = 100 + Math.sin(cubeSineDriver) * 500;
            smokeMesh.position.z = 100 + Math.sin(cubeSineDriver) * 500;


            // TESTING SPOTLIGHT TARGET
            // console.log('Math.sin( time * 2.5 ): ', Math.sin( time * 2.5 ));
            // spotLight.target.position.x = Math.sin( time * 2.5 );


            requestAnimationFrame( animate );

            // if (littleM.position.z > 0.15) {
            //     littleM.position.z -= .1
            // }

            // if (bigM.position.y > 5) {
            //     bigM.position.y -= .2
            // }

            // OBJECT POSITIONING


            littleM.rotation.y -= 0.01;
            bigM.rotation.y -= -0.01;
            // camera.lookAt(t.position);
            // console.log('littleM.position: ', littleM.position);
            // camera.lookAt(bigM.position);
            

            renderer.render(scene, camera);
        };

        // load a ground texture
        var texture = new THREE.TextureLoader().load('./lava.jpeg');
        texture.wrapS = texture.wrapT = THREE.
        RepeatWrapping;
        texture.repeat.set (12,12);


        // create ground material
        let lavaMaterial = new THREE.MeshPhysicalMaterial({map:texture,bumpMap:texture});

        // load object texture
        var metalTexture = new THREE.TextureLoader().load('./metal.jpg');


        // create ground mesh
        var groundGeometry = new THREE.PlaneBufferGeometry
        ( 300,300 );
        var ground = new THREE.Mesh( groundGeometry, 
        lavaMaterial );
        ground.rotation.z = Math.PI/180 * -45;
        ground.rotation.x = Math.PI/180 * -90;
        ground.position.y=-2.0;
        // scene.add(ground);


        var envMap = new THREE.CubeTextureLoader()
        .setPath( 'skybox/')
        .load( [ 'right.jpg', 'left.jpg', 'top.jpg', 'bottom.jpg', 'front.jpg', 'back.jpg' ] );


        // create Tetrahedron
        // var tetGeometry = new THREE.TetrahedronBufferGeometry(2,0);
        // var metalMaterial = new THREE.MeshPhysicalMaterial( { map:metalTexture, envMap: envMap, metalness: 5.0,roughness: 5.0 });
        // var metalMaterial = new THREE.MeshPhysicalMaterial( { map:metalTexture, envMap: envMap, metalness: 0.0,roughness: 0.0 });
        var metalMaterial = new THREE.MeshPhysicalMaterial( { envMap: envMap, metalness: 0.0,roughness: 0.0 });
        // var metalMaterial = new THREE.MeshPhysicalMaterial({map:metalTexture, bumpMap:texture, metalness: 0.3,roughness: 0.5});
        // t = new THREE.Mesh( tetGeometry, metalMaterial );
        // t.rotation.x=Math.PI/180*-10;
        // scene.add( t );



        // ORBITALS
        // for (let i=0;i<=num;i++){
        //     // create new mesh
        //     var sphereGeometry = new THREE.SphereBufferGeometry( .1,6,6  );
        //     var material = new THREE.MeshPhysicalMaterial( { envMap:envMap, metalness:1.0 } ) ;
        //     var particle = new THREE.Mesh( sphereGeometry, material );

        //     // set random position
        //     particle.position.set(Math.random()*100.0 - 
        //     50.0,0.0 ,Math.random()* - 10.0 );
        //     // calc distnace as constant and assign 
        //     // to object
        //     var a = new THREE.Vector3( 0, 0, 0 );
        //     var b = particle.position;
        //     var d = a.distanceTo( b );
        //     particle.distance = d;    


        //     // define 2 random but constant angles 
        //     // in radians
        //     particle.radians = Math.random()*360 * Math.
        //     PI/180; // initial angle
        //     particle.radians2 = Math.random()*360 * Math.
        //     PI/180; // initial angle    

        //     // add object to scene
        //     scene.add( particle );	
        //     // add to collection
        //     objects.push( particle );     
        // }


















        // const loader = new GLTFLoader();
        // loader.load( './gltf/big.glb', function (gltf) {
        //     littleM = gltf.scene
        //     gltf.scene.scale.set( 2, 2, 2 );
        //     gltf.scene.position.x = .1;				    //Position (x = right+ left-) 
        //     gltf.scene.position.y = .1;				    //Position (y = up+, down-)
	    //     gltf.scene.position.z = .1;				    //Position (z = front +, back-)
	    //     scene.add( gltf.scene );            
        // },
        // // called while loading is progressing
        // function ( xhr ) {
        //     console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
        // },
        // // called when loading has errors
        // function ( error ) {
        //     console.log( 'An error happened' );
        // })

        // OBJ
        // instantiate a loader
        const loader = new OBJLoader();

        // load a resource
        loader.load(
            // resource URL
            'models/little.obj',
            // called when resource is loaded
            function ( object ) {


                object.traverse( function( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        child.material = metalMaterial;
                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.geometry.center();
                    }
                } );


                littleM = object
                object.scale.set( .02, .02, .02 );
                object.position.x = 0;
                object.position.y = 8.0;
                object.position.z = 0.0;

                scene.add( littleM );
            },
            // called when loading is in progresses
            function ( xhr ) {
                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // called when loading has errors
            function ( error ) {
                console.log( 'An error happened' );
            }
        );

        

        // load a resource
        loader.load(
            // resource URL
            'models/big.obj',
            // called when resource is loaded
            function ( object ) {

                object.traverse( function( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        child.material = metalMaterial;
                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.geometry.center();
                    }
                } );

                bigM = object
                object.scale.set( .02, .02, .02 );
                object.position.x = 0;
                object.position.y = 14;
                object.position.z = 0;
                scene.add( bigM );
            camera.lookAt(new THREE.Vector3(0,8,0));

            },
            // called when loading is in progresses
            function ( xhr ) {
                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // called when loading has errors
            function ( error ) {
                console.log( 'An error happened' );
            }
        );


            let controls = new OrbitControls( camera, renderer.domElement );
            controls.enableZoom = true;



        // start animation loop
        animate();

</script>
<h1>Miles Morgan Photography</h1>
</body>
</html>
